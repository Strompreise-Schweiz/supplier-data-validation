name: "Reusable: Validate static tariff"

on:
  workflow_call:
    inputs:
      tariff_schema_version:
        description: "Tariff schema version to validate against (e.g., v1, v2)"
        required: true
        default: "v1"
        type: string
      tariff_name:
        description: "Folder name of the tariff (e.g., 'emn-050')"
        required: true
        type: string
      tariff_year:
        description: "Tariff file name (4-digit year, e.g., '2025')"
        required: true
        type: string

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install ajv + formats
        run: npm i ajv@8 ajv-formats@3 ajv-errors@3

      # 1) Check inputs & path
      - name: Validate inputs
        shell: bash
        run: |
          set -euo pipefail

          if ! [[ "${{ inputs.tariff_name }}" =~ ^[a-z0-9-]{3,}$ ]]; then
            echo "Invalid 'tariff_name': '${{ inputs.tariff_name }}' (expected lowercase letters, digits, hyphens; min length 3)"
            exit 1
          fi

          if ! [[ "${{ inputs.tariff_year }}" =~ ^[0-9]{4}$ ]]; then
            echo "Invalid 'tariff_year': '${{ inputs.tariff_year }}' (expected 4 digits like 2025)"
            exit 1
          fi

          TARIFF_PATH="data/tariffs/${{ inputs.tariff_name }}/${{ inputs.tariff_year }}.json"
          echo "TARIFF_PATH=${TARIFF_PATH}" >> "$GITHUB_ENV"
          echo "Tariff file path: ${TARIFF_PATH}"

          if [[ ! -f "${TARIFF_PATH}" ]]; then
            echo "Tariff file not found: ${TARIFF_PATH}"
            exit 1
          fi
          jq -e . "${TARIFF_PATH}" >/dev/null

      # 2) Download schema & AJV check
      - name: Download tariff schema (${{ inputs.tariff_schema_version }})
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL \
            "https://raw.githubusercontent.com/Strompreise-Schweiz/supplier-data-validation/main/tariffs/static/${{ inputs.tariff_schema_version }}/tariff.schema.json" \
            -o _tariff.schema.json

      - name: Validate tariff.json (Ajv 2020 + formats + ajv-errors)
        shell: bash
        run: |
          set -euo pipefail
          node - <<'NODE'
          const fs = require('fs');

          // Use Ajv 2020 draft
          const Ajv = require('ajv/dist/2020').default;
          const addFormats = require('ajv-formats').default;
          const ajvErrors = require('ajv-errors');

          const schema = JSON.parse(fs.readFileSync('_tariff.schema.json','utf8'));
          const data   = JSON.parse(fs.readFileSync(process.env.TARIFF_PATH,'utf8'));

          const ajv = new Ajv({
            strict: true,
            allErrors: true,   // required for ajv-errors to show all messages
          });
          addFormats(ajv);
          ajvErrors(ajv);      // enables "errorMessage" in the schema

          const validate = ajv.compile(schema);
          const ok = validate(data);

          if (!ok) {
            const toPath = (p) => p || '(root)';
            const lines = validate.errors.map(e => `${toPath(e.instancePath)}: ${e.message}`);
            console.error(lines.join('\n'));
            process.exit(1);
          }
          console.log('AJV schema validation passed with friendly messages.');
          NODE

      # 2) Top-level year bounds + monthly coverage (exactly 1..12, no overlaps)"
      - name: "Lint: top-level year bounds + monthly coverage"
        shell: bash
        env:
          TARIFF_PATH: ${{ env.TARIFF_PATH }}
          TARIFF_YEAR: ${{ inputs.tariff_year }}
        run: |
          set -euo pipefail
          node - <<'NODE'
          const fs = require('fs');

          const path = process.env.TARIFF_PATH;
          const yearStr = process.env.TARIFF_YEAR;
          if (!/^\d{4}$/.test(yearStr)) throw new Error(`Invalid TARIFF_YEAR: ${yearStr}`);
          const YEAR = Number(yearStr);

          const raw = fs.readFileSync(path, 'utf8');
          const json = JSON.parse(raw);

          // ---------- Helpers ----------
          const isISODate = (s) => /^\d{4}-\d{2}-\d{2}$/.test(s);
          const isISODateTime = (s) => /^\d{4}-\d{2}-\d{2}T/.test(s);
          const extractYMD = (s) => {
            if (typeof s !== 'string') throw new Error(`Date must be a string, got ${typeof s}`);
            // Accept both "YYYY-MM-DD" and full ISO datetime; slice the date part
            const m = s.slice(0, 10);
            if (!/^\d{4}-\d{2}-\d{2}$/.test(m)) {
              throw new Error(`Invalid date or datetime format: "${s}" (expected YYYY-MM-DD or ISO 8601 datetime)`);
            }
            const [y, mo, d] = m.split('-').map(Number);
            return { y, mo, d, raw: s, datePart: m };
          };

          // ---------- 1) Check top-level valid_from / valid_to ----------
          if (!('valid_from' in json)) throw new Error("Missing 'valid_from' at top level");
          if (!('valid_to' in json)) throw new Error("Missing 'valid_to' at top level");

          const vf = extractYMD(json.valid_from);
          const vt = extractYMD(json.valid_to);

          // Year must match input year
          if (vf.y !== YEAR) throw new Error(`'valid_from' year must be ${YEAR} (got ${vf.y})`);
          if (vt.y !== YEAR) throw new Error(`'valid_to' year must be ${YEAR} (got ${vt.y})`);

          // Must be Jan 1 .. Dec 31 of that year (date part check, time/tz allowed)
          const mustStart = `${YEAR}-01-01`;
          const mustEnd   = `${YEAR}-12-31`;
          if (vf.datePart !== mustStart) {
            throw new Error(`'valid_from' must be ${mustStart} (got ${vf.raw})`);
          }
          if (vt.datePart !== mustEnd) {
            throw new Error(`'valid_to' must be ${mustEnd} (got ${vt.raw})`);
          }

          // ---------- 2) Monthly coverage checks ----------
          const prices = json.prices || [];
          if (!Array.isArray(prices) || prices.length === 0) {
            throw new Error("'prices' must be a non-empty array");
          }

          const covered = new Set();
          prices.forEach((p, i) => {
            if (!Array.isArray(p.months) || p.months.length === 0) {
              throw new Error(`prices[${i}] missing or empty 'months' array`);
            }
            p.months.forEach((m) => {
              if (!Number.isInteger(m) || m < 1 || m > 12) {
                throw new Error(`prices[${i}] has invalid month '${m}' (must be 1..12)`);
              }
              if (covered.has(m)) {
                throw new Error(`Overlap: month ${m} appears in multiple periods (conflict at prices[${i}])`);
              }
              covered.add(m);
            });
          });

          const missing = [];
          for (let m = 1; m <= 12; m++) if (!covered.has(m)) missing.push(m);
          if (missing.length) {
            throw new Error(`Monthly coverage incomplete: missing months ${missing.join(', ')}`);
          }

          console.log("OK: valid_from/valid_to match calendar year bounds, and months cover exactly 1..12 with no overlaps.");
          NODE

