name: "Reusable: Validate static tariff"

on:
  workflow_call:
    inputs:
      tariff_schema_version:
        description: "Tariff schema version to validate against (e.g., v1, v2)"
        required: true
        default: "v1"
        type: string
      tariff_name:
        description: "Folder name of the tariff (e.g., 'emn-050')"
        required: true
        type: string
      tariff_year:
        description: "Tariff file name (4-digit year, e.g., '2025')"
        required: true
        type: string

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install ajv + formats
        run: npm i ajv@8 ajv-formats@3 ajv-errors@3

      # 1) Check inputs & path
      - name: Validate inputs
        shell: bash
        run: |
          set -euo pipefail

          if ! [[ "${{ inputs.tariff_name }}" =~ ^[a-z0-9-]{3,}$ ]]; then
            echo "Invalid 'tariff_name': '${{ inputs.tariff_name }}' (expected lowercase letters, digits, hyphens; min length 3)"
            exit 1
          fi

          if ! [[ "${{ inputs.tariff_year }}" =~ ^[0-9]{4}$ ]]; then
            echo "Invalid 'tariff_year': '${{ inputs.tariff_year }}' (expected 4 digits like 2025)"
            exit 1
          fi

          TARIFF_PATH="data/tariffs/${{ inputs.tariff_name }}/${{ inputs.tariff_year }}.json"
          echo "TARIFF_PATH=${TARIFF_PATH}" >> "$GITHUB_ENV"
          echo "Tariff file path: ${TARIFF_PATH}"

          if [[ ! -f "${TARIFF_PATH}" ]]; then
            echo "Tariff file not found: ${TARIFF_PATH}"
            exit 1
          fi
          jq -e . "${TARIFF_PATH}" >/dev/null

      # 2) Download schema & AJV check
      - name: Download tariff schema (${{ inputs.tariff_schema_version }})
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL \
            "https://raw.githubusercontent.com/Strompreise-Schweiz/supplier-data-validation/main/tariffs/static/${{ inputs.tariff_schema_version }}/tariff.schema.json" \
            -o _tariff.schema.json

      - name: Validate tariff.json (Ajv 2020 + formats + ajv-errors)
        shell: bash
        run: |
          set -euo pipefail
          node - <<'NODE'
          const fs = require('fs');

          // Use Ajv 2020 draft
          const Ajv = require('ajv/dist/2020').default;
          const addFormats = require('ajv-formats').default;
          const ajvErrors = require('ajv-errors');

          const schema = JSON.parse(fs.readFileSync('_tariff.schema.json','utf8'));
          const data   = JSON.parse(fs.readFileSync(process.env.TARIFF_PATH,'utf8'));

          const ajv = new Ajv({
            strict: true,
            allErrors: true,   // required for ajv-errors to show all messages
          });
          addFormats(ajv);
          ajvErrors(ajv);      // enables "errorMessage" in the schema

          const validate = ajv.compile(schema);
          const ok = validate(data);

          if (!ok) {
            const toPath = (p) => p || '(root)';
            const lines = validate.errors.map(e => `${toPath(e.instancePath)}: ${e.message}`);
            console.error(lines.join('\n'));
            process.exit(1);
          }
          console.log('AJV schema validation passed with friendly messages.');
          NODE

      # 2) Top-level year bounds + monthly coverage (exactly 1..12, no overlaps)"
      - name: "Lint: strict valid_from/valid_to (ISO tz) + monthly coverage"
        shell: bash
        env:
          TARIFF_PATH: ${{ env.TARIFF_PATH }}
          TARIFF_YEAR: ${{ inputs.tariff_year }}
        run: |
          set -euo pipefail
          node - <<'NODE'
          const fs = require('fs');

          const path = process.env.TARIFF_PATH;
          const yearStr = process.env.TARIFF_YEAR;
          if (!/^\d{4}$/.test(yearStr)) throw new Error(`Invalid TARIFF_YEAR: ${yearStr}`);
          const YEAR = Number(yearStr);

          const raw = fs.readFileSync(path, 'utf8');
          const json = JSON.parse(raw);

          // ---------- Helpers ----------
          const ISO_TZ = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}[+-]\d{2}:\d{2}$/;

          function requireField(obj, key) {
            if (!(key in obj)) throw new Error(`Missing '${key}' at top level`);
            const val = obj[key];
            if (typeof val !== 'string') throw new Error(`'${key}' must be a string (got ${typeof val})`);
            if (!ISO_TZ.test(val)) throw new Error(`'${key}' must match YYYY-MM-DDTHH:MM:SS+HH:MM (e.g., 2025-01-01T00:00:00+01:00), got '${val}'`);
            return val;
          }

          function ymd(s) {
            // assumes format is valid per ISO_TZ
            return s.slice(0, 10); // YYYY-MM-DD
          }

          function yearOf(s) { return Number(s.slice(0, 4)); }

          // ---------- 1) Check top-level valid_from / valid_to ----------
          const vf = requireField(json, 'valid_from');
          const vt = requireField(json, 'valid_to');

          // Year must match input year
          if (yearOf(vf) !== YEAR) throw new Error(`'valid_from' year must be ${YEAR} (got ${yearOf(vf)})`);
          if (yearOf(vt) !== YEAR) throw new Error(`'valid_to' year must be ${YEAR} (got ${yearOf(vt)})`);

          // Exact bounds in Europe/Zurich (offset +01:00)
          const mustStart = `${YEAR}-01-01T00:00:00+01:00`;
          const mustEnd   = `${YEAR}-12-31T23:59:59+01:00`;

          if (vf !== mustStart) throw new Error(`'valid_from' must be exactly ${mustStart} (got ${vf})`);
          if (vt !== mustEnd)   throw new Error(`'valid_to' must be exactly ${mustEnd} (got ${vt})`);

          // ---------- 2) Monthly coverage checks ----------
          const prices = json.prices || [];
          if (!Array.isArray(prices) || prices.length === 0) {
            throw new Error("'prices' must be a non-empty array");
          }

          const covered = new Set();
          prices.forEach((p, i) => {
            if (!Array.isArray(p.months) || p.months.length === 0) {
              throw new Error(`prices[${i}] missing or empty 'months' array`);
            }
            p.months.forEach((m) => {
              if (!Number.isInteger(m) || m < 1 || m > 12) {
                throw new Error(`prices[${i}] has invalid month '${m}' (must be 1..12)`);
              }
              if (covered.has(m)) {
                throw new Error(`Overlap: month ${m} appears in multiple periods (conflict at prices[${i}])`);
              }
              covered.add(m);
            });
          });

          const missing = [];
          for (let m = 1; m <= 12; m++) if (!covered.has(m)) missing.push(m);
          if (missing.length) {
            throw new Error(`Monthly coverage incomplete: missing months ${missing.join(', ')}`);
          }

          console.log("OK: strict valid_from/valid_to with timezone, and months cover exactly 1..12 with no overlaps.");
          NODE

