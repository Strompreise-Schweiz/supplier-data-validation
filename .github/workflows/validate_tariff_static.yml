name: "Reusable: Validate static tariff"

on:
  workflow_call:
    inputs:
      tariff_schema_version:
        description: "Tariff schema version to validate against (e.g., v1, v2)"
        required: true
        default: "v1"
        type: string
      tariff_name:
        description: "Folder name of the tariff (e.g., 'emn-050')"
        required: true
        type: string
      tariff_year:
        description: "Tariff file name (4-digit year, e.g., '2025')"
        required: true
        type: string

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install ajv + formats
        run: npm i ajv@8 ajv-formats@3 ajv-errors@3

      # 1) Check inputs & path
      - name: Validate inputs
        shell: bash
        run: |
          set -euo pipefail

          if ! [[ "${{ inputs.tariff_name }}" =~ ^[a-z0-9-]{3,}$ ]]; then
            echo "Invalid 'tariff_name': '${{ inputs.tariff_name }}' (expected lowercase letters, digits, hyphens; min length 3)"
            exit 1
          fi

          if ! [[ "${{ inputs.tariff_year }}" =~ ^[0-9]{4}$ ]]; then
            echo "Invalid 'tariff_year': '${{ inputs.tariff_year }}' (expected 4 digits like 2025)"
            exit 1
          fi

          TARIFF_PATH="data/tariffs/${{ inputs.tariff_name }}/${{ inputs.tariff_year }}.json"
          echo "TARIFF_PATH=${TARIFF_PATH}" >> "$GITHUB_ENV"
          echo "Tariff file path: ${TARIFF_PATH}"

          if [[ ! -f "${TARIFF_PATH}" ]]; then
            echo "Tariff file not found: ${TARIFF_PATH}"
            exit 1
          fi
          jq -e . "${TARIFF_PATH}" >/dev/null

      # 2) Download schema & AJV check
      - name: Download tariff schema (${{ inputs.tariff_schema_version }})
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL \
            "https://raw.githubusercontent.com/Strompreise-Schweiz/supplier-data-validation/main/tariffs/static/${{ inputs.tariff_schema_version }}/tariff.schema.json" \
            -o _tariff.schema.json

      - name: Validate tariff.json (Ajv 2020 + formats + ajv-errors)
        shell: bash
        run: |
          set -euo pipefail
          node - <<'NODE'
          const fs = require('fs');

          // Use Ajv 2020 draft
          const Ajv = require('ajv/dist/2020').default;
          const addFormats = require('ajv-formats').default;
          const ajvErrors = require('ajv-errors');

          const schema = JSON.parse(fs.readFileSync('_tariff.schema.json','utf8'));
          const data   = JSON.parse(fs.readFileSync(process.env.TARIFF_PATH,'utf8'));

          const ajv = new Ajv({
            strict: true,
            allErrors: true,   // required for ajv-errors to show all messages
          });
          addFormats(ajv);
          ajvErrors(ajv);      // enables "errorMessage" in the schema

          const validate = ajv.compile(schema);
          const ok = validate(data);

          if (!ok) {
            const toPath = (p) => p || '(root)';
            const lines = validate.errors.map(e => `${toPath(e.instancePath)}: ${e.message}`);
            console.error(lines.join('\n'));
            process.exit(1);
          }
          console.log('AJV schema validation passed with friendly messages.');
          NODE

      # 3) Additional linting: exact 1-year coverage, no gaps/overlaps, all months covered
      - name: "Lint: continuous yearly coverage (no gaps/overlaps) + monthly coverage"
        shell: bash
        env:
          TARIFF_PATH: ${{ env.TARIFF_PATH }}
          TARIFF_YEAR: ${{ inputs.tariff_year }}
        run: |
          set -euo pipefail
          node - <<'NODE'
          const fs = require('fs');

          function parseISO(s) {
            const t = Date.parse(s);
            if (Number.isNaN(t)) throw new Error(`Invalid ISO timestamp: ${s}`);
            return t;
          }

          // Iterate all (year, month) pairs touched by [startMs, endMs)
          function* iterMonthsInRange(startMs, endMs) {
            const start = new Date(startMs);
            const end = new Date(endMs);

            let y = start.getUTCFullYear();
            let m = start.getUTCMonth(); // 0..11
            // Normalize to the first day of the start month (UTC)
            let cursor = new Date(Date.UTC(y, m, 1, 0, 0, 0, 0));

            // If the normalized cursor is after the actual start, step back one month
            if (cursor.getTime() > startMs) {
              m -= 1;
              if (m < 0) { m = 11; y -= 1; }
              cursor = new Date(Date.UTC(y, m, 1, 0, 0, 0, 0));
            }

            while (cursor.getTime() < endMs) {
              const monthStart = new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth(), 1));
              const monthEnd   = new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth() + 1, 1));
              // Check overlap with [startMs, endMs)
              const overlap = Math.max(0, Math.min(monthEnd.getTime(), endMs) - Math.max(monthStart.getTime(), startMs));
              if (overlap > 0) {
                yield { y: cursor.getUTCFullYear(), m: cursor.getUTCMonth() + 1 }; // 1..12
              }
              cursor = monthEnd;
            }
          }

          const path = process.env.TARIFF_PATH;
          const yearStr = process.env.TARIFF_YEAR;
          if (!/^\d{4}$/.test(yearStr)) throw new Error(`Invalid TARIFF_YEAR: ${yearStr}`);
          const YEAR = Number(yearStr);

          const raw = fs.readFileSync(path, 'utf8');
          const json = JSON.parse(raw);
          const prices = json.prices || [];
          if (!Array.isArray(prices) || prices.length === 0) {
            throw new Error("prices must be a non-empty array");
          }

          const periods = prices.map((p, i) => {
            if (!p.start_timestamp || !p.end_timestamp) {
              throw new Error(`prices[${i}] missing start_timestamp or end_timestamp`);
            }
            const startMs = parseISO(p.start_timestamp);
            const endMs = parseISO(p.end_timestamp);
            if (!(endMs > startMs)) {
              throw new Error(`prices[${i}] has end <= start (${p.start_timestamp} .. ${p.end_timestamp})`);
            }
            return { i, startMs, endMs, start: p.start_timestamp, end: p.end_timestamp, months: p.months };
          }).sort((a,b) => a.startMs - b.startMs);

          // Check for gaps/overlaps
          for (let i = 1; i < periods.length; i++) {
            const prev = periods[i-1];
            const curr = periods[i];
            if (curr.startMs < prev.endMs) {
              throw new Error(`Overlap: period ${curr.i} starts ${curr.start} before previous end ${prev.end}`);
            }
            if (curr.startMs !== prev.endMs) {
              throw new Error(`Gap: period ${curr.i} starts ${curr.start} but previous ended ${prev.end}`);
            }
          }

          // Exact calendar-year coverage: [YEAR-01-01T00:00+01:00 .. (YEAR+1)-01-01T00:00+01:00)
          const expectedStartStr = `${YEAR}-01-01T00:00:00+01:00`;
          const expectedEndStr   = `${YEAR+1}-01-01T00:00:00+01:00`;
          const expectedStart = parseISO(expectedStartStr);
          const expectedEnd   = parseISO(expectedEndStr);

          const actualStart = periods[0].startMs;
          const actualEnd   = periods[periods.length - 1].endMs;

          if (actualStart !== expectedStart || actualEnd !== expectedEnd) {
            const iso = (ms) => new Date(ms).toISOString();
            throw new Error(
              `Coverage must be exactly ${expectedStartStr} .. ${expectedEndStr} `
              + `(got ${iso(actualStart)} .. ${iso(actualEnd)})`
            );
          }

          // Month coverage: ensure months 1..12 are covered based on timestamps
          const covered = new Set();
          for (const p of periods) {
            for (const { m } of iterMonthsInRange(p.startMs, p.endMs)) {
              covered.add(m);
            }
          }
          const missing = [];
          for (let m = 1; m <= 12; m++) if (!covered.has(m)) missing.push(m);
          if (missing.length) {
            throw new Error(`Monthly coverage incomplete: missing months ${missing.join(', ')}`);
          }

          // Optional: if a period declares a 'months' array, validate it matches the derived months
          periods.forEach(p => {
            if (Array.isArray(p.months) && p.months.length > 0) {
              const fromTs = p.startMs, toTs = p.endMs;
              const derived = new Set();
              for (const { m } of iterMonthsInRange(fromTs, toTs)) derived.add(m);
              const declared = new Set(p.months);
              const a = [...derived].sort((x,y)=>x-y).join(',');
              const b = [...declared].sort((x,y)=>x-y).join(',');
              if (a !== b) {
                throw new Error(`prices[${p.i}] months mismatch: declared [${b}] vs derived from timestamps [${a}]`);
              }
            }
          });

          console.log("OK: continuous, no overlaps, exactly one calendar year, all 12 months covered.");
          NODE
